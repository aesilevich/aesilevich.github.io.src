---
title:  "Ref-qualifiers"
date:   2021-01-12 12:00:00 +0700
comments: true
tags: [c++, it]
---

Сегодня похоже день каких-то удивительных открытий.
Сейчас копался в исходниках ranges в libstdc++ и наткнулся на вот такое объявление функции-члена в классе: `void foo() &&`.
Оказывается, что в C++11 были введены по аналогии с квалификаторами const и volatile квалификаторы rvalue и lvalue references
на функции-члены.

<!--more-->

Теперь допускается использовать такие квалификаторы для нестатических функций-членов:
{{< highlight cpp >}}
// старые
void foo();
void foo() const;

// новые
void foo() &;
void foo() &&;
void foo() const &;
void foo() const &&;
{{< /highlight >}}

При этом нельзя смешивать новые и старые квалификаторы, будет ошибка компиляции.

Вот ссылка на хорошую статью, в которой описывается зачем они были введены и как работают. Судя по всему, там вообще весь
блог довольно интересен:

[https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/](https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/)