---
title:  "Использование C++20 Ranges в интерфейсах классов"
date:   2021-01-12 12:00:00 +0700
comments: true
tags: [c++, it]
draft: true
---

В этой статье хочу рассказать об опыте применения C++20 Ranges в интерфейсах классов и о
проблеммах, возникающих при этом, а также предложить способы решения этих проблем.

# Простой пример

Начну с простого примера попытки использования ranges в интерфейсе класса, в котором,
казалось бы, они должны очень хорошо работать. Допустим у нас есть класс `user_list`,
который хранит внутри себя список пользователей, представленных классом `user`,
и содержит логику работы с этим списком. Предположим, что мы хотим во всём остальном
коде однозначно идентифицировать пользователя по указателю на объект класса `user`,
т. е. для каждого пользователя создаётся уникальный объект, адрес которого не меняется
во время работы программы. Для этого в классе `user_list` будет храниться контейнер
(возьмём для простоты `std::vector`) с уникальными указателями на объекты класса `user`,
выделенными в heap:
{{< highlight cpp >}}
class user_list {
    // ...
private:
    std::vector<std::unique_ptr<user>> users_;
};
{{< /highlight >}}

Теперь мы хотим предоставить возможность пользователям класса `user_list`
получать список пользователей только для чтения и работать с ним. Самым первым решением,
которое приходит в голову, будет сделать метод-getter для `users_`:
{{< highlight cpp >}}
auto & users() const {
    retur users_;
}
{{< /highlight >}}

Это работает не так, как мы задумывали, потому что метод `users` возвращает тип
`const std::vector<std::unique_ptr<user>> &`, но квалификатор `const` обеспечивает
неизменяемость только значений в самом векторе, но не значений объектов класса
`user`. Следующий код с вызовом метода `modify`, меняющего значение объекта класса `user`,
будет компилироваться:
{{< highlight cpp >}}
user_list lst;

//...

for (auto && u : lst.users()) {
    // метод modify меняет значение объекта класса user
    u->modify();
}
{{< /highlight >}}


Думаю, что эта проблема знакома всем, кто пишет код на C++. Раньше она решалась довольно
непростым способом: написанием пользовательских итераторов, преобразующих значения из
`std::unuqie_ptr<user>` в `const user *`, и добавлением методов `begin()` и `end()`, которые
возвращают эти итераторы. Для упрощения этой задачи можно использовать, например,
`boost::iterator_adaptor`, но всё равно требуется написать довольно много кода. Но теперь
в C++20 у нас есть ranges, с помощью которых, казалось бы, эта проблема должна решаться тривиально.
Для этого надо применить адаптер `std::ranges::views::transform`, передав ему функтор
(или лямбда-функцию), выполняющую нужные преобразования:
{{< highlight cpp >}}
auto users() const {
    constexpr auto fn = [](auto && uptr) {
        return const_cast<const user*>(uptr.get());
    };
    return users_ | std::ranges::views::transform(fn);
}

// ...

for (auto && u : lst.users()) {
    u->get_name();  // OK: вызов константного метода класса user
    u->modify();    // ошибка: вызов modify отбрасывает квалификатор const
}
{{< /highlight >}}


На первый взгляд решение работает идеально, но у него есть довольно неприятные проблемы.
Например, следующий код, который получает указатель на первого пользователя, не будет работать:
{{< highlight cpp >}}
assert(!std::ranges::empty(lst.users()));
// на следующей строке будет ошибка компиляции
const user * first_user = *std::ranges::begin(lst.users());
{{< /highlight >}}


При попытке скомпилировать приведённый выше код компилятор выдаст довольно длинное сообщение
об ошибке, суть которого сводится к тому, что отсутствует функция `std::ranges::begin`,
принимающая в качестве аргумента значение, возвращаемое вызовом `lst.users()`. Конкретно в этом
случае проблему можно обойти, сохранив значение, которое возвращает `lst.users()`, во временную
переменную:
{{< highlight cpp >}}
auto ulist = lst.users();
assert(!std::ranges::empty(ulist));
// всё ок, код компилируется и работает
const user * first_user = *std::ranges::begin(ulist);
{{< /highlight >}}

Этот код будет работать как и предполагается, но проблема по-прежнему остаётся. Вызов
`std::ranges::begin(lst.users())` не компилируется не просто так. Это сделано намеренно в стандартной
библиотеке, потому что итераторы, возвращаемые функциями `begin` и `end` для view,
полученного применением адаптера `transform`, становятся невалидными после разрушения этого view.
Это может привести к гораздо более серьёзным проблемам уже во время выполнения, которые будет
не так просто отловить. Например, следующий код приводит к неопределённому поведению, хотя
может и работать в зависимости от разных условий:
{{< highlight cpp >}}
user_list lst;

// ...

// Функция возвращает итератор, указывающий на первого пользователя
// с заданным именем, но этот итератор невалиден.
auto find_first_with_name(const std::string & name) {
    auto ulist = lst.users();
    return std::ranges::find_if(ulist, [name](auto && u) {
        return u->name() == name;
    });
}

// ...

auto first = find_first_with_name("user 1");
auto ulist = lst.users();

// неопределённое поведение: итератор first невалиден
for (auto it = first;
     it != std::ranges::end(ulist) && (*it)->name() == "user 1";
     ++it) {
    std::cout << "NAME: " << (*it)->name() << std::endl;
}
{{< /highlight >}}


Cитуация выглядит странной: список пользователей существует и не
изменяется, но итераторы, предназначенные для обхода этого списка, могут стать невалидными
просто из-за изменения небольших деталей в коде. Таких проблем не возникает при использовании
одного из старых подходов,
когда метод-getter возвращает просто ссылку на вектор, или когда мы реализуем пользовательский
итератор и возвращаем его методами `begin` и `end` класса `user_list`.

Более того, теперь возникают вопросы по поводу времени жизни и валидности всех интервалов в цепочке
адаптеров. Например, следующий код не является корректным, потому что view, возвращаемый из функции,
хранит в себе ссылку на вектор, который уничтожается в момент выхода из фукнции:
{{< highlight cpp >}}
auto make_range() {
    std::vector<int> v = {10, 20};
    constexpr auto fn = [](auto && x) { return x * x; };
    return v | std::ranges::views::transform(fn);
}
{{< /highlight >}}

А следующий код уже будет корректным (что в общем то и предполагается интуитивно):
{{< highlight cpp >}}
std::vector<int> v = {10, 20};

auto make_range2() {
    auto tmp = std::ranges::views::reverse(v);
    constexpr auto fn = [](auto && x) { return x * x; };
    return tmp | std::ranges::views::transform(fn);
}
{{< /highlight >}}

Во втором примере view `tmp`, сконструированный адаптером `reverse`, хранит в себе ссылку на глобальный
вектор, но view, сконструированный адаптером `transform`, уже хранит в себе не ссылку на `tmp`,
а его копию, хотя и в первом, и во втором примере адаптеру `transform` передаётся ссылка
на lvalue.

Каковы общие правила хранения интервалов в цепочках view? В каких случаях итераторы интервала
остаются валидными после разрушения самого интервала? Какие пути существуют для решения проблемы,
описанной в начале этого раздела? Для того, чтобы ответить на все эти вопросы,
надо углубиться в определения базовых концептов интервалов. Об этом пойдёт речь в следующем разделе.


# Концепты range, borrowed_range и view

Для начала следует разобраться с формальным определением интервала, который представлен
в стандартной библиотеке концептом `std::ranges::range`. Стандарт определяет,
что тип `T` является интервалом, если для значения `x` типа `T &` являются корректными вызовы
`std::ranges::begin(x)` и `std::ranges::end(x)`, и они возвращают итераторы, указывающие
на начало и конец интервала.
Другими словами, тип является интервалом, если одним из стандартных способов
(методами класса или глобальными функциями `begin` и `end`)
определено получение итераторов, указывающих на начало и конец интервала, по lvalue ссылке на этот тип.

Таким образом, концепт интервала не накладывает никаких ограничений на комбинации квалификатора
`const` (при условии, что определены методы `begin` и `end` для константного объекта) и
lvalue/rvalue ссылок. Например, для вектора следующие статические проверки будут проходить:
{{< highlight cpp >}}
static_assert(std::ranges::range<std::vector<int>>);
static_assert(std::ranges::range<std::vector<int> &>);
static_assert(std::ranges::range<const std::vector<int> &>);
static_assert(std::ranges::range<std::vector<int> &&>);
{{< /highlight >}}

Точно так же будут проходить статические проверки для типа `std::ranges::transform_view`
(результата применения адаптера `std::ranges::views::transform`):
{{< highlight cpp >}}
static_assert(std::ranges::range<std::ranges::transform_view<...>>);
static_assert(std::ranges::range<std::ranges::transform_view<...> &>);
static_assert(std::ranges::range<const std::ranges::transform_view<...> &>);
static_assert(std::ranges::range<std::ranges::transform_view<...> &&>)
{{< /highlight >}}

С концептом `range` мы разобрались. Получается, что в контексте этой статьи он нас не особо
инетесует, поскольку не накладывает никаких ограничений для ссылочных типов. Теперь
перейдём к рассмотрению концепта `std::ranges::view`, которому должны удовлетворять views,
т. е. результаты применения адаптеров к интервалам.

Концепт `std::ranges::view` определяется следующим образом:
{{< highlight cpp >}}
namespace std::ranges {
    struct view_base {};

    template<typename T>
    inline constexpr bool enable_view = derived_from<T, view_base>;

    template<typename T>
    concept view = range<T> &&
                   movable<T> &&
                   default_initializable<T> &&
                   enable_view<T>;
}
{{< /highlight >}}
